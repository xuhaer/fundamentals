## 第1章 构造过程抽象(Building Abstractions with Procedures)
### 1.1 程序设计的基本元素(The Elements of Programming)

一个强力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。这样，当我们描述一种语言时，就需要将注意力特别放在这一语言所提供的，能够将简单的认识组合起来形成更复杂知识的方法方面。每一种强有力的语言都为此提供了三种机制: 
* 基本表达形式：用于表示语言所关心的最简单的个体。
* 组合的方法：通过它们可以从较为简单的东西出发构造出复合的元素。
* 抽象的方法：通过它们可以为复合对象命名，并将他们当作单元去操作。

在程序设计中，我们需要处理两类元素：过程和数据。非形式地说，数据是一种我们希望操作的‘东西’，而过程就是有关操作这些‘东西’的规则的描述。这样，任何强有力的程序设计语言都必须能有表述基本的数据和基本的过程，还需要提供对过程和数据进行组合和抽象的方法。

**应用序求值：所有被传入的实际参数都会立即被求值**
**正则序求值：传入的实际参数只有在有需要时才会被求值**

一个程序往往可以分解成多个独立的过程，而这一分解的重要性，并不在于它将一个问题分解成了几个部分。这里最关键的是分解中的每一个过程完成了一件可以清楚标明的工作，这使它们可以被用作定义其它过程的模块。在这样做时，我们根本无需关注这个过程是如何计算出它的结果的，只需要注意它能计算出某个我们想要的结果的事实(关于如何得到某结果的细节被隐藏了)，即所谓的`过程抽象`。

由此可见，一个过程定义应该能够隐藏起一些细节。这将使过程的使用者可能不必自己去写这些过程，而是从其它程序员那里作为一个黑箱而接受了它。用户在使用一个过程时，应该不需要去弄清楚它是如何实现的。

**局部名**
过程的形式参数在过程体里扮演着一种非常特殊的角色，在这里，形式参数的具体名字是什么本质上没有关系。这样的名字称为`约束变量`，因此一个过程的定义`约束`了它的所有形式参数。一个名字的定义被约束于的那个表达式集合称为这个名字的`作用域`。



### 1.2 过程与它们所产生的计算(Procedures and the Processes They Generate)

在这一节里，我们将考察由一些简单过程所产生的计算过程的“形状”，还将研究这些计算过程消耗各种重要计算资源(时间和空间)的速率。

#### 线性的递归和迭代

```scheme
(define (factorial n) (if (= n 1)
        1
        (* n (factorial (- n 1)))))
```
```scheme
;计算3!的线性递归过程
(factorial 3)
        (* 3 (factorial 2))
        (* 3 (* 2 (factorial 1)))
        (* 3 (* 2 1))
        (* 3 2)
        6
```

```scheme
;计算3!的线性迭代过程
(factorial 3)
(fact-iter 1 1 3) ;product <-- counter * product
(fact-iter 1 2 3) ;counter <-- counter + 1
(fact-iter 2 3 3)
6
```

虽然这两种计算过程都是同一定义域里的同一个数学函数，都需要使用与 n 正比的步骤数去计算出 `n!`。得到同样的部分的乘积序列。但如果我们考虑这两个计算过程的“形状”，就会发现它们的进展情况大不相同。

对于前者：其揭示出一种先逐步展开而后收缩的形状。在展开阶段里，这一计算过程构造起一个`推迟进行的操作`所形成的链条，收缩阶段表现为这些运算的实际执行。这种类型的计算过程由一个推迟执行的运算链条刻画，称为一个`递归计算过程`。在计算`n!`时，推迟执行的乘法链条的长度也就是为保存其轨迹需要保存的信息量，这个长度随着 n 值而线性增长，这样的计算过程被称为`线性递归过程`。

与之对应，第二种计算过程里并没有任何增长或者收缩。对于任何一个 n，在计算过程中的每一步，我们需要保存的轨迹的所有变量就是 product、counter、max_count 的当前值。我们称这种过程为一个`迭代计算过程`。一般来说，迭代计算过程就是那种其状态可以用固定数目的`状态变量`描述的计算过程，与此同时，又存在一套描述这些变量的更新方式和一个结束检测。在计算`n!`时，所需要的计算步骤随着 n 线性增长，这种过程称为`线性迭代过程`。

尾递归: 总能将在常量空间中执行迭代型计算过程，即使这一计算过程是用一个`递归过程描述的`。
大多数语言没有这个优化，而对于LISP/erlang/prolog这种鼓励递归的语言是有的。

另外，不要混淆`递归过程`和`递归计算过程`；当我们说一个过程是递归的时候，论述的是一个语法形式上的事实，说明这个过程的定义中(直接或间接)引用了该过程本身。在说某一计算过程具有某个模式时(如，线性递归)，我们说的是这一计算过程的进展方式，而不是相应过程书写上的语法形式。

💡 欧几里得算法求最大公约数(GCD)所需要的步数是对数增长的，这一事实与斐波那契数列有一种有趣的关系: 
> Lame 定理:如果欧几里得算法需要用 k 步计算出一对整数的 GCD，那么这对数中较小的那个数必然大于或等于第 k 个斐波那契数。





