赋值和局部状态

在一个由许多对象组成的对象里，其中的这些对象极少会是完全独立的。每个对象都可能通过交互作用，影响其它对象的状态，所谓交互就是建立起一个对象的状态变量与其它对象的状态变量之间的联系。

要使这样的一个模型成为模块化的，就要求它能分解为一批计算对象，使它们能够模拟系统里的实际对象。每一个计算对象必须有它自己的一些局部状态变量，用于描述实际对象的状态。如果我们希望通过程序设计语言里常规的符号名字去模拟状态变量，那么语言里就必须有一个赋值运算符，使我们能够用它去改变与一个名字相关联的值。

而将赋值引进所用的程序设计语言，将会使我们陷入许多困难的概念问题的丛林之中。但无论如何，将系统看作是一集带有局部状态的对象，也是一种维护模块化设计的强有力技术。

与所有状态都必须显式地操作和传递额外参数的方式相比，通过引进赋值和将状态隐藏在局部变量中的技术，我们能够以一种更模块化的方式构造系统。

只要我们不使用赋值，以同样参数对同一过程的两次求值一定产生出同样的结果，因此就可以认为过程是在计算数学的函数。像前两章所做的那样，不用任何赋值的程序设计称为函数式程序设计。与其对应的，广泛采用赋值的程序设计被称为命令式程序设计，这种模式除了会导致计算模型的复杂性之外，以命令式风格写出的程序还很容易出现一些不会在函数式程序中出现的错误。一般而言，带有赋值的程序将强迫人们去考虑赋值的相对顺序，以保证每个语句所用的是被修改变量的正确版本。而在函数式程序设计中，这类问题根本就不会出现。(如果考虑有着多个并发执行的进程的应用程序，命令式程序设计的复杂性还会变得更糟糕)



与所有状态都必须显式地操作和传递额外参数的方式相比，通过引进赋值和将状态隐藏在局部变量中的技术，我们能以一种更模块化的方式构造系统。



以局部过程定义作为程序模块化的有用技术中的两个关键性质：

- 局部过程的名字不会与包容它们的过程之外的名字相互干扰，这是因为这些局部过程名都是在该过程运行时创建的框架里面约束的，而不是在全局环境里约束的。
- 局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数。这是因为对于局部过程体的求值所在的环境是外围过程求值所在的环境的下属。



并发程序的正确行为:

对于并发进程，我们对于赋值就更需要特别小心，因为在这里可能无法控制其他进程所做赋值的而出现顺序。如果几个这样的修改可能并发出现，我们就需要采用某些方式以保证系统的行为是正确的。

对于并发的一种可能限制方式是规定，修改任意共享状态变量的两个操作都不允许同时发生。这是一个特别严厉的要求，这样做可能过于低效和保守。

对于并发的另一种不那么严厉的限制方式是，保证并发系统产生出的结果与各个进程按照某种方式顺序运行产生出的结果完全一样。

对于并发程序的正确执行，我们还块而已提出一些更弱的要求。一个模拟扩散过程的程序(例如，在某个对象里面的热量流动)可以由一大批进程组成，每个进程代表空间中很小的一点体积，它们并发地更新自己的值。这里的每个进程都反复将自己的值更新为自己的原值和相邻进程的值的平均值。无论有关的操作按什么顺序执行，这种算法都能收敛到正确的解，因此也就不需要对于共享变量的并发使用提出任何限制了。

