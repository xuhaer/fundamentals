# 第八章 优化服务器设置

在这一章，我们将解释为 MySQL 服务器创建一个靠谱的配置文件的过程。

MySQL 有大量可以修改的参数——但不应该随便去修改，除非是明确地知道默认值会有问题。

### 8.1 MySQL 配置的工作原理

首先应该知道的是 MySQL 从哪里获得配置信息：命令行参数和配置文件。在类 UNIX 系统中，配置文件一般在 /etc/my.conf 或 /etc/mysql/my.cnf。

任何打算长期使用的设置都应该写到全局配置文件，而不是在命令行特别指定。

配置项设置都使用小写，单词之间用下划线或横线隔开(等价)，但建议使用一种固定的风格(下划线)。

配置项可以用多个作用域，有些设置是服务器级的(全局)，有些是对每个连接生效的(会话作用域)，剩下的一些都是对象级的。

除了在文件中设置变量，有很多变量也可以在服务器运行时修改——称为动态配置变量(需要注意的是MySQL关闭时可能丢失这些配置)。

如果在服务器运行时修改了变量的全局值，这个值对当前会话和其他任何已经存在的会话都不起效果，因为会话的变量值是在链接创建时从全局值初始化来的。在每次变化后，应该检查 SHOW GLOBAL VARIABLERS 的输出，确认是否按期望值改变了。

作为一个经验法则，日志文件的全部大小，应该足够容纳服务器一个小时的活动内容。

## 8.7 基于工作负载配置

#### 优化 BLOB 和 TEXT 的场景

BLOB 和 TEXT 列对于 MySQL 来说是特殊类型的场景(我们把所有 BLOB 和 TEXT 都简称为 BLOB 类型，因为它们属于相同类型的数据)。BLOB 值有几个限制使得服务器对它的处理跟其他类型不一样。一个最重要的是：服务器不能在内存临时表中存储 BLOB 值，因此，如果一个查询涉及 BLOB 值，又需要使用临时表——不管它多小——都会立即在磁盘上创建临时表。这样效率很低，尤其对于小而快的查询。

有两种办法来减轻这个不利的情况：通过 SUBSTRING()函数把值转换为 VARCHAR，或者让临时表更快一些。

让临时表运行更快的最好方式是：**把它们放在基于内存的文件系统(GNU/Linux上是 tempfs)**。这会降低一些开销，尽管这依然比内存表慢得多。因为操作系统会避免把数据写到磁盘，所以内存文件系统可以帮助提升性能。一般的文件系统也可以在内存中缓存，但是操作系统会每隔几秒就刷新一次，而 tmpfs 文件系统从来不会刷新。

对于很长的变长列(例如,BL0B、TEXT,以及长字符列), InnoDB存储一个768字节的前缀在行内。如果列的值比前缀长, InnoDB会在行外分配扩展存储空间来存剩下的部分。它会分配一个完整的16KB的页,像其他所有的 InnodB页面一样,每个列都有自己的页面(不同的列不会共享扩展存储空间)。 InnoDB一次只为一个列分配一个页的扩展存储空间,直到使用了超过32个页以后,就会一次性分配64个页面。

注意,我们说过 InnoDB可能会分配扩展存储空间。如果总的行长(包括大字段的完整长度)比 InnoDB的最大行长限制要短(比8KB小一些), InnoDB将不会分配扩展存储空间,即使大字段( Long column)的长度超过了前缀长度。

最后,当 InnoDB更新存储在扩展存储空间中的大字段时,将不会在原来的位置更新。而是会在扩展存储空间中写一个新值到一个新的位置,并且不会删除旧的值。

所有这一切都有以下后果:

* 大字段在 InnoDB里可能浪费大量空间。例如,若存储字段值只是比行的要求多了个字节,也会使用整个页面来存储剩下的字节,浪费了页面的大部分空间。同样的,如果有一个值只是稍微超过了32个页的大小,实际上就需要使用96个页面。

* 扩展存储禁用了自适应哈希,因为需要完整地比较列的整个长度,才能发现是不是正确的数据(哈希帮助 InnoDB非常快速地找到“猜测的位置”,但是必须检査“猜测的位置”是不是正确)。因为自适应哈希是完全的内存结构,并且直接指向 Buffer Pool中访问“最”频繁的页面,但对于扩展存储空间却无法使用自适应哈希。

* 太长的值可能使得在查询中作为 WHERE条件不能使用索引,因而执行很慢。在应用 WHERE条件之前, MySQL需要把所有的列读出来,所以可能导致 MySQL要求InnoDB读取很多扩展存储,然后检查 WHERE条件,丢弃所有不需要的数据。查询不需要的列绝不是好主意,在这种特殊的场景下尤其需要避免这样做。如果发现查询正遇到这个限制带来的问题,可以尝试通过覆盖索引来解决部分问题。

* 如果一张表里有很多大字段,最好是把它们组合起来单独存到一个列里面,比如说 用XML文档格式存储。这让所有的大字段共享一个扩展存储空间,这比每个字段用自己的页要好。

* 有时候可以把大字段用C0MPRESS5()压缩后再存为BL0B,或者在发送到 MySQL前在应用程序中进行压缩,这可以获得显著的空间优势和性能收益。

  

