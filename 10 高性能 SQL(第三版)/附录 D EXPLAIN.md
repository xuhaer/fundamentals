# 附录 D EXPLAIN

EXPLAIN命令是查看查询优化器如何决定执行查询的主要方法。这个功能有局限性,并不总会说出真相,但它的输出是可以获取的最好信息,值得花时间了解,因为可以学习到查询是如何执行的。学会解释 EXPLAIN将帮助你了解 MySQL优化器是如何工作的。

## 调用 EXPLAIN

要使用 EXPLAIN,只需在查询中的 SELECT关键字之前增加 EXPLAIN这个词。 MySQL会在查询上设置一个标记。当执行查询时,这个标记会使其返回关于在执行计划中每一步的信息,而不是执行它。它会返回一行或多行信息,显示出执行计划中的每一部分和执行的次序。



要意识到 EXPLAIN只是个近似结果,别无其他。有时候它是一个很好的近似,但在其他时候,可能与真相相差甚远。以下是一些相关的限制。

* EXPLAIN根本不会告诉你触发器、存储过程或UDF(用户自定义函数)会如何影响查询。
* 它并不支持存储过程,尽管可以手动抽取查询并单独地对其进行 EXPLAIN操作。
* 它并不会告诉你 MySQL在查询执行中所做的特定优化。
* 它并不会显示关于查询的执行计划的所有信息( MySQL开发者会尽可能增加更多信息)
* 它并不区分具有相同名字的事物。例如,它对内存排序和临时文件都使用 "filesort", 并且对于磁盘上和内存中的临时表都显示"Using temporary"。

## 重写非 SELECT查询(MySQL 5.6 允许解释非 SELECT 查询)

MySQL EXPLAIN只能解释 SELECT查询,并不会对存储程序调用和 INSERT、 UPDATE、DELETE或其他语句做解释。然而,你可以重写某些非 SELECT查询以利用 EXPLAIN。为了达到这个目的,只需要将该语句转化成一个等价的访问所有相同列的 SELECT。任何提及的列都必须在 SELECT列表,关联子句,或者WHERE子句中。

## EXPLAIN 中的列

EXPLAIN 的输出总是有相同的列，可变的是行数及内容。

###  id列

这一列总是包含一个编号,标识 SELECT所属的行。如果在语句当中**没有子查询或联合**,那么只会有唯一的 SELECT,于是每一行在这个列中都将显示一个1。否则,内层的SELECT语句一般会顺序编号,对应于其在原始语句中的位置。

**MySQL将 SELECT查询分为简单和复杂类型,复杂类型可分成三大类:简单子查询、所谓的派生表(在FROM子句中的子查询),以及 UNION查询。**

注："FR0N子句中的子查询是派生表" 这一表述是对的,但“派生表是FR0M子句中的子查询”则不对,术语“派生表”在SQL中含义很宽泛。

下面是一个简单的子查询：

```mysql
mysql> EXPLAIN SELECT (SELECT 1 FROM actor LIMIT 1) FROM film;
```


### select_type列

这一列显示了对应行是简单还是复杂 SELECT(如果是后者,那么是三种复杂类型中的哪种)。SIMPLE值意味着查询不包括子査询和 UNION。如果查询有仼何复杂的子部分,则最外层部分标记为 PRIMARY,其他部分标记如下。
- SUBQUERY: 包含在 SELECT列表中的子查询中的 SELECT(换句话说,不在FROM子句中)标记为SUBQUERY。
- DERIVED: DERIVED值用来表示包含在FROM子句的子查询中的 SELECT, MySQL会递归执行并将结果放到一个临时表中。服务器内部称其“派生表”,因为该临时表是从子查询中派生来的。
- UNION: 在UNI0N中的第二个和随后的 SELECT被标记为UNI0N。
- UNION RESULT: 用来从 UNION的匿名临时表检索结果的 SELECT被标记为 UNION RESULT。

除了这些值, SUBQUERY和UNION还可以被标记为 DEPENDENT和 UNCACHEABLE。 DEPENDENT 意味着 SELECT依赖于外层查询中发现的数据; UNCACHEABLE意味着 SELECT中的某些特性阻止结果被缓存于一个 Item cache中。

### table 列
这一列显示了对应正在访问哪个表。



### type列

MySQL用户手册上说这一列显示了“关联类型”,但我们认为更准确的说法是访问类型—换言之就是 MySQL决定如何查找表中的行。下面是最重要的访问方法,依次从最差到最优。

**ALL**

​	这就是人们所称的全表扫描,通常意味着 MySQL必须扫描整张表,从头到尾,去找到需要的行。(这里也有个例外,例如在查询里使用了 LIMIT,或者在 Extra列中显示“ Using distinct,/ not exists”。)

**index**

​	这个跟全表扫描一样,只是 MySQL扫描表时按索引次序进行而不是行。它的主要优点是避免了排序;最大的缺点是要承担按 索引次序读取整个表的开销。这通常意味着若是按随机次序访问行,开销将会非常大。如果在 Extra列中看到“ Using index”,说明 MySQL正在使用覆盖索引,它只扫描索引的数据,而不是按索引次序的每一行。它比按索引次序全表扫描的开销要少很多。

**range**

​	范围扫描就是一个有限制的索引扫描,它开始于索引里的某一点,返回匹配这个值域的行。这比全索引扫描好一些,因为它用不着遍历全部索引。显而易见的范围扫描是带有 BETWEEN或在 WHERE子句里带有>的查询。

​	当 MySQL使用索引去查找一系列值时,例如IN()和0R列表,也会显示为范围扫描。然而,这两者其实是相当不同的访问类型,在性能上有重要的差异。更多信息可以查看第5章的文章“什么是范围条件”。 此类扫描的开销跟索引类型相当。

**ref**

​	这是一种索引访问(有时也叫做索引查找),它返回所有匹配某个单个值的行。然而,它可能会找到多个符合条件的行,因此,它是查找和扫描的混合体。此类索引访问只有当使用非唯一性索引或者唯一性索引的非唯一性前缀时才会发生。把它叫做ref是因为索引要跟某个参考值相比较。这个参考值或者是一个常数,或者是来自多表查询前一个表里的结果值。

​	ref or null是ref之上的一个变体,它意味着 MySQL必须在初次查找的结果里进行第二次查找以找出NUL条目。

**eq_ref**

​	使用这种索引查找, MySQL知道最多只返回一条符合条件的记录。这种访问方法可以在 My SQL使用主键或者唯一性索引查找时看到,它会将它们与某个参考值做比较。 MySQL对于这类访问类型的优化做得非常好,因为它知道无须估计匹配行的范围或在找到匹配行后再继续查找。

**const, system**

​	当 My SQL能对查询的某部分进行优化并将其转换成一个常量时,它就会使用这些访问类型。举例来说,如果你通过将某一行的主键放入 WHERE子句里的方式来选取此行的主键, MySQL就能把这个查询转换为一个常量。然后就可以高效地将表从联接执行中移除。

**NULL**

​	这种访问方式意味着 MySQL能在优化阶段分解查询语句,在执行阶段甚至用不着再访问表或者索引例如,从一个索引列里选取最小值可以通过单独查找索引来完成,不需要在执行时访向表。





# 附录E

## 锁的调试

任何使用锁来控制资源共享的系统,锁的竞争问题都不好调试。当我们给某个表增加列新字段,或者只是进行查询,就有可能发现其他请求锁住了操作的表或者行。此时,通常你所想做的事就是找出查询阻塞的原因,从而知道该杀死哪个进程。这个附录显示了如何达到这两个目标。



## 服务器级别的所等待

**表锁**

表可以被显式的读锁和写锁进行锁定。这些锁有许多的变种,例如本地读锁。你可以在 MySQL手册LO CK TABLES部分了解到这些变种。除了这些显式的锁外,查询过程中还有隐式的锁。

**全局锁**

可以通过 FLUSH TABLES WITH READ LOCK或设置 read only=1来获取单个全局读锁。它与任何表锁都冲突。



### 表锁

表锁既可以是显式的也可以是隐式的。显式的锁用LOCK TABLES 创建。隐式的为服务器在查询过程中创建，如一个长时间的查询：

```mysql
mysql> SELECT SLEEP(30) FROM sakila.film LIMIT 1;
```

当这个查询运行时，如果你再次尝试锁住(显式、隐式均可)表sakila.film，操作会因隐式锁而挂起。

**关于隐式锁和显式锁的差异：**从内部来说,它们有相同的结构,由相同的 MySQL服务器代码来控制。从外部来说,你可以通过LOCK TABLES和UNLOCK TABLES 来控制显式锁。此外，对于非MyISAM存储引擎时，它们之间有一个重要区别：当创建显示锁时，它会按照你的指令来做，但隐式锁就比较隐蔽并"有魔幻性"，服务器会在需要时自动地创建和释放隐式锁，并将它们传递给存储引擎。



### 全局读锁

mysql服务器还实现了一个全局读锁，可以如下获取该锁：

```mysql
FLUSH TABLES WITH READ LOCK;
```

如果此时在另外一个会话中尝试再锁住这个表，结果会像之前一样挂起：

```mysql
LOCK TABLES sakila.film WRITE;
```

如果判断这个查询是在等待全局读锁而不是一个表级别的锁呢: `SHOW PROCESSLIST`的输出中`State`的状态是`Waiting for release of readlock`。不过mysql没有提供查出谁持有全局读锁的方法。



### 命名锁

命名锁是一种表锁:服务器在重命名或删除一个表时创建。命名锁与普通的表锁相冲突,无论是隐式的还是显式的。例如,如果和之前一样使用LOCK TABLES,然后在另外一个会话中尝试对此表重命名,查询会挂起,但这次不是处于 Locked状态。



### 用户锁

在服务器中实现的最后一种锁是用户锁，它基本是一个命名互斥量，你需要制定锁的名称字符串，以及等待的超时秒数。

```mysql
SELECT GET_LOCAK('my lock', 100);
```

