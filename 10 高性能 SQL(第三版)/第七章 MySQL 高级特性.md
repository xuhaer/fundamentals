# 第七章 MySQL 高级特性

## 7.1 分区表

分区表对于用户来说就是一个表，但是底层实际上是物理隔离的多个子表。

Mysql中的分区表，每个子表有自己的索引，没有整个父表的索引。

**分区表的使用场景如下：**

- 表非常大，几GB以及以上级别，或者表的最后部分是热点数据，其他部分都是历史数据，很少查询，也很少改写。这样我们使用分区表时可以只查询某个子表的数据。

- 分区表的数据易于维护，可以整个删除某个分区的数据，还可以针对某个独立分区进行一些优化、检查、修复等操作。

- 分区表的数据可以分布在不同的物理设备上。

- 可以利用分区表避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问、ext3文件系统的inode 锁竞争等。

- 可以备份和恢复某个独立的分区，这在非常大的数据集的场景下非常有用。

  

**分区表有一些限制：**

- 一个表最多只能有1024个分区。
- 分区字段中有主键或者唯一索引列的时候，所有的主键列和唯一索引列都必须包含进来。
- 分区表无法使用外键约束。
- 所有分区都必须使用同一存储引擎。

### 分区表原理

以下是RUID操作的分区表底层逻辑：
`SELECT`：

​	查询一个分区表时，会先打开并锁住所有的分区子表，优化器判断是否可以过滤部分分区，然后再调用存储引擎来访问各个分区的数据
`INSERT`：

​	写入一条记录时，同样地，先打开并锁住所有的分区子表，确定哪个分区接收这条记录，然后写入对应子表
`DELETE`：

​	一样的，打开并锁住所有分区表，然后确定数据对应分区，然后在相应子表上删数据
`UPDATE`：

​	一样，先打开并锁住所有分区表，然后找到要改的数据，修改，然后判断改后的数据应该放在哪个分区，就写入哪个分区子表，删除之前分区子表中的那条数据

### 7.1.2 分区表的类型

MySQL 支持多种分区表，我们看到最多的是根据范围进行分区。

```sql
mysql> CREATE TABLE sales(
	order_date DATETIME NOT NULL,
	-- Other columns omitted
)ENGINE=InnoDB PARTITION BY RANGE(YEAR(order_date))(
	PARTITION p_2010 VALUES LESS THAN (2010),
	PARTITION p_2011 VALUES LESS THAN (2011),
	PARTITION p_2012 VALUES LESS THAN (2012),
	PARTITION p_catchall VALUES LESS THAN MAXVALUE
);
```

### 7.1.3 如何使用分区表

当希望从一个非常大的表中查询出一段时间的记录，而这个表中包含了很多年的历史数据，数据都是按时间排序的。

这正是分区要做的事情，理解分区时还可以将其当做索引的最初形态，以代价非常小的方式定位的需要的数据在哪一片“区域”，为了保证大数据量的可扩展性，一般有下面两个策略：

**全表扫描数据，不要任何索引**

​	可以使用简单的分区存放表，不要任何索引，根据分区的规则大致定位需要的数据未知。

**索引数据，并分离热点**

​	如果数据有明显的“热点”，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据有机会都缓存在内存中。这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效地使用缓存。

### 7.1.4什么情况下会出问题

上面我们介绍的两个分区策略都基于两个非常重要的假设：查询都能够过滤(prunning)掉很多额外的分区、 分区本身井不会带来很多额外的代价。 而事实证明， 这两个假设在某些场景下会有问题。 下面介绍一些可能会遇到的问题。

* **NULL值会使分区过滤无效**

  关于分区表一个容易让人误解的地方就是分区的表达式的值可以是NULL:第一个 分区是一个特殊分区。假设按照PARTITIONBY RANGE YEAR(order_date)分区，**那么所有order_date为NULL或者是一个非法值的时候，记录都会被存放到第一个 分区**。现在假设有下面的查询：WHERE order_date BElWEEN'2012-01-01'AND '2012-01-31'。实际上，MySQL会检查两个分区检查第一个分区是因为YEAR()函数在接收非法值的时候可能会返回NULL值，那么这个范围的值可能会返回NULL而被存放到第一个分区了。

   如果第一个分区非常大，特别是当使用“全量扫描数据，不要任何索引”的策略时， 代价会非常大。

  **在MySQL5.5中就不需要这个优化技巧了**，因为可以直接使用列本身而不是基于列的函数进行分区：PARTITION BY RANGE COLUMNS(order_date)。

* **分区列和索引列不匹配**

   如果定义的索引列和分区列不匹配， 会导致查询无法进行分区过滤。 

  假设在列a上定义了索引， 而在列b上进行分区。 因为每个分区都有其独立的索引， 所以扫描列b上的索引就需要扫描每一个分区内对应的索引。 如果每个分区内对应索引的非叶子节点都在内存中， 那么扫描的速度还可以接受， 但如果能跳过某些分区索引当然会更好。要避免这个问题， 应该避免建立和分区列不匹配的索引， 除非查询中还同时包含了可以过滤分区的条件。

* **选择分区的成本可能很高**

  如前所述分区有很多类型， 不同类型分区的实现方式也不同， 所以它们的性能也各不相同。 尤其是范围分区， 对于回答 “这一行属于哪个分区” 这些符合查询条件的行在哪些分区” 这样的问题的成本可能会非常高， 因为服务器需要扫描所有的分区定义的列表来找到正确的答案。 类似这样的线性搜索的效率不高， 所以随着分区 数的增长， 成本会越来越高。

* **维护分区的成本可能很高**

   某些分区维护操作的速度会非常快， 例如新增或者删除分区（当删除一个大分区可能会很慢， 不过这是另一回事）。 而有些操作， 例如重组分区或者类似 ALTER 语句的操作：这类操作需要复制数据。 重组分区的原理与 ALTER 类似， 先创建一个临时的分区， 然后将数据复制到其中， 最后再删除原分区。

### 7.1.5查询优化

分区最大的优点就是优化器可以根据分区函数来过滤一些分区。所以，**对于访问分区表来说，很重要的一点是要在WHERE条件中带入分区列，有时候即使看似多余的也要带上**，这样就可以让优化器能够过滤掉无须访问的分区。如果没有这些条件，MySQL就需要让对应存储引擎访问这个表的所有分区，如果表非常大的话， 就可能会非常慢。

另外， MySQL 在使用分区函数的列本身进行比较时才能过滤分区，而不能根据表达式的值去过滤分区，即使这个表达式就是分区函数也不行。

## 7.2 视图

视图就是一个虚拟的表，其数据实际上是来源于真实的表。
因此，对视图的删改查实际上是对形成视图的真实的表的删改查。

```sql
mysql>CREATE VIEW oceania AS 
SELECT * FROM country WHERE continent = 'Oceania'
WITH CHECK OPTION;
```

其中，`WITH CHECK OPTION`语句是限制使用视图更新时，更新的东西必须是视图条件内的行。比如要去更新一个continent != ‘Oceania’的数据是不行的，只能更新等于Oceania的数据

#### 视图的限制

- 不能对视图创建触发器
- 使用临时表算法实现的视图，无法被更新
- 无法使用SHOW CREATE VIEW来查看视图定义语句

## 7.3 外键约束

使用外键是有成本的。比如外键通常都要求每次在修改数据时都要在另外一张表中多执行一次查找操作。虽然 InnoDB强制外键使用索引,但还是无法消除这种约束检查的开销。

如果外键列的选择性很低,则会导致一个非常大且选择性很低的索引。例如,在一个非常大的表上有 status列,并希望限制这个状态列的取值,如果该列只能取三个值——虽然这个列本身很小,但是如果主键很大,那么这个索引就会很大—而且这个索引除了做这个外键限制,也没有任何其他的作用了。

不过,在某些场景下,外键会提升一些性能。**如果想确保两个相关表始终有一致的数据,那么使用外键比在应用程序中检查一致性的性能要高得多**,此外,外键在相关数据的删除和更新上,也比在应用中维护要更高效,不过,外键维护操作是逐行进行的,所以这样的更新会比批量删除和更新要慢些。

外键约束使得查询需要额外访问一些别的表,这也意味着需要额外的锁。如果向子表中写入一条记录,外键约束会让 InnoDB检查对应的父表的记录,也就需要对父表对应记录进行加锁操作,来确保这条记录不会在这个事务完成之时就被删除了。这会导致额外的锁等待,甚至会导致一些死锁。因为没有直接访问这些表,所以这类死锁问题往往难以排查

有时,可以使用触发器来代替外键。对于相关数据的同时更新，那么外键更合适,但是如果外键只是用作数值约束,那么触发器或者显式地限制取值会更好些。(这里,可以直接使用ENUM类型。)

如果只是使用外键做约束,那通常在应用程序里实现该约束会更好。外键会带来很大的额外消耗。

## 7.4 在 MySQL 内部存储代码

MySQL 允许通过触发器、储存过程、函数的形式来存储代码，还可以在定时任务中存放代码。有人提倡使用存储代码，也有人反对，一般来说，存储代码是一种很好的共享和复用代码的方法，综合来说，将代码逻辑放入数据库有以下好处：

- 在服务器内部运行，离数据最近，节省带宽，改善延迟
- 代码重用，可统一业务规则，保证行为一致
- 简化代码维护和版本更新
- 可以帮助提升安全，比如提供更细粒度的权限控制
- 服务器端可以缓存存储过程的执行计划，这样对于反复执行的过程，会降低服务器消耗

* 因为是在服务器端部署的，所以备份、维护都可以在服务器端完成。所以存储程序的维护工作会很简单。

存储代码也有如下缺点：

- MySQL没有提供好的开发和调试工具
- 代码执行效率比应用程序的代码差一些，能使用的函数有限，很难实现复杂的逻辑
- 存储过程有安全隐患，尤其注意不应该将加密过程放在存储过程里，否则数据库一旦攻破，加密数据和加密方法将同时被黑客得到
- 给数据库服务器带来额外压力，而数据库服务器一般扩展性比应用服务器差，不可能在需要的时候立马加一台数据库服务器来化解压力
- 数据库服务器可没有什么垃圾回收机制，资源消耗都要编程者自己小心注意

### 7.4.1 存储过程和函数

创建一个简单的存储过程的例子，用来写入一定数量的数据到一个表中：

```sql
mysql>DROP PROCEDURE IF EXISTS insert_many_rows;

delimiter //

CREATE PROCEDURE insert_many_rows (IN loops INT)
BEGIN
	DECLARE v1 INT; -- IN、OUT、INOUT。IN是调用者传入的参数，但是传入后该参数的改变调用者无法“看到”。INOUT也是调用者传入的参数并且可以指定初始化值，但是该参数的改变调用者是可以“看到”的。OUT是一个初始化值为NULL的参数，不管你调用的时候给它设置什么值都没用，你只能传一个变量来得到最终输出的参数。
	SET v1=loops;
	WHILE v1 > 0 DO -- 不要忘了 DO 这个关键字
		INSERT INTO test_table values(NULL, 0,'hahah');
		SET v1 = v1 - 1;
	END WHILE;
END;
//
delimiter ;
```

### 7.4.1 触发器

触发器就是在增删改的时候，可以自动地执行一段逻辑代码。还可以指定是增删改之前触发还是之后。

触发器有一些特别需要注意的地方：

* 针对每个表的每一个事件，只能有一个触发器。
* MySQL 只支持""基于行的触发"——也就是说，触发器始终是针对一条记录的，而不是针对整个 SQL 语句的。如果变更数据集很大，效率会很低。

下面这些触发器本身的限制也适用于 MySQL：

- 触发器可以掩盖服务器背后的工作，一个简单的 SQL 语句背后，因为触发器，可能包含了很多看不见的工作。

- 激活触发器的语句也会失败，这会导致难于分析和定位，不知道是原语句的问题还是触发器的问题。

- 触发器可能导致死锁和锁等待。如果触发器失败，那么原来的 SQL 语句也会失败。如果没有意识到这其中是触发器在搞鬼，那么很难理解服务器抛出的错误代码是什么意思。

  

### 7.4.2 事件

事件有点类似于 Linux 的定时任务，不过是完全在 MySQL 内部实现的。通常，我们会把复杂的 SQL 都封装到一个存储过程中，这样事件在执行的时候只需要做一个简单的CALL 调用。

```sql
CREATE EVENT optimize_somdb ON SCHEDULE EVERY 1 WEEK
DO
CALL optimize_tables('somedb');
```

另外，如果一个定时事件执行需要很长事件，那么有可能会出现前面事件还未执行完成，下一个事件点的事件又开始了。所以需要用户自己编写这种情况下的防并发代码。可以使用函数 GET_LOCK()来确保当前总是只有一个事件在被执行：

```sql
CREATE EVENT optimize_somdb ON SCHEDULE EVERY 1 WEEK
DO
BEGIN
	DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
		BEGIN END;
	IF GET_LOCK('somedb', 0) THEN
		DO CALL optimize_tables('somedb');
END
```

这里的"CONTINUE HANDLER"用来确保，即使当事件出现了异常，仍然会释放持有的锁。



## 7.6 绑定变量

当查询语句的解析和执行计划生成消耗了主要的事件，那么绑定变量可以在一定程度上解决问题。因为只需要解析一次，对于大量重复类型的查询语句，性能会有很大的提高。另外，执行计划的缓存和传输使用的二进制协议，这都使得绑定变量的方式要比普通 SQL 语句执行的方式要更快。



## 7.7 用户自定义函数

从很早开始，MySQL 就支持用户自定义函数(UDF)。存储过程只能使用 SQL 来编写，而 UDF 没有这个限制，你可以使用 C 语言调用约定的任何编程语言来实现。



## 7.9 字符集和校对

主要问题在于，Mysql有一堆和字符集有关的设置，然而，用户常常搞不清楚到底哪个设置生效…………

Mysql的字符集设置是逐层嵌套的，整个服务器有字符集的设置，表有字符集的设置，表中的某列也有字符集的设置。这些设置都是从下而上逐层覆盖的，先看列的设置，列没设置就算表的设置，表也没设置那就认整个服务器的设置。

下面是一些常用设置的介绍：

- character_set_client：服务器端收到客户端的字符时，总是假设客户端的字符是这个设置配置的字符集

- character_set_connection：一旦收到了客户端的字符，服务器端会先将字符转换成这个设置所配置的字符集，即会从character_set_client的字符集转换为character_set_connection的字符集

- character_set_result：服务器端返回数据时，总是将数据的字符由character_set_connection的字符集转换为character_set_result的字符集

- character_set_server：整个服务器字符集的默认设置

- character_set_database：默认数据库的字符集的设置，当没有使用`use database`命令来指定要使用的数据库时，这个值和character_set_server是一样的。如果你切换了正在使用的数据库，这个值会跟着改变

- character_set_filesystem：指定当使用`LOAD DATA INFILE`和`SELECT...INTO OUTFILE`语法的时候，文件的文件名使用的字符集。

- character_set_system：服务器存储标识符的时候使用的字符集，总是utf-8，应当是不可动态修改的吧

- character_sets_dir：指定字符集设置存放的路径，也是不可动态修改的值

  

## 7.12 查询缓存

在前几章已有提及，MySQL在服务器的入口处有个命中查询缓存的过程，一旦命中，立刻返回之前缓存的查询结果，而无需执行解析、优化、查询这些阶段。

查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有的缓存数据都将失效。这种机制效率比较低，但这种简单实现代价很小，而后者对非常繁忙的系统来说还是很重要的。

随着现在的通用服务器越来越强大，查询缓存被发现是一个影响服务器扩展性的因素。因此作者的意见是应该默认关闭查询缓存，如果缓存的作用很大的话，建议设置一个较小的缓存空间，比如几十兆。

**MySQL是如何判断缓存命中的？有如下要点：**

* MySQL是通过哈希查找来判断缓存命中的，将查询语句，查询涉及的数据库、客户端协议版本等影响返回结果的信息变成哈希值和返回结果存储在一张引用表里。这意味着，查询语句中的任何字符的改变，甚至多一个空格，注释，都有可能影响命中。

* 当查询语句中有不确定的数据时，查询结果根本不会缓存，比如now()这样的函数，由于查询结果不会缓存，那么缓存也就不会命中了。另外，查询中包含自定义函数、存储函数、用户变量、临时表、系统表等等都不会被缓存。(MySQL 在任何时候只要发现不能被缓存的部分，就会禁止这个查询被缓存。)

**查询缓存可能会带来的额外消耗**

* 打开查询缓存意味着所有的查询语句涉及读操作的，都要先检查是否命中缓存。
* 所有读操作结束返回结果的时候，如果结果可以被缓存，需要将结果存入缓存。
* 写操作结束时，需要将查询缓存中因为写操作而失效的缓存都消除。
* 如果在一个事务中修改了某个表，由于要保证事务的隔离性，会限制这个表对应的查询缓存，在这个事务结束之前，任何外部事务包括这个事务，都无法使用跟这个表有关的缓存，也无法对涉及这个表的查询进行缓存。因此，长时间运行的事务会降低缓存命中率。
* 缓存在失效的时候，消除失效缓存的操作由一个全局锁保护，导致所有检查缓存命中和检查缓存失效的查询都要等待，这个时候系统可能会僵死一会儿。这就是为什么书中不推荐使用查询缓存或者推荐设置很小的缓存空间的原因。

**查询缓存相关设置**

query_cache_type：查询缓存的开关，有ON、OFF、DEMAND三个可选值，其中DEMAND的意思是，只有用户在查询语句中用SQL_CACHE指明才使用查询缓存。
query_cache_size：缓存使用的总空间，必须是1024的整数倍，单位为字节。
query_cache_min_res_unit：查询缓存分配内存时的最小单位
query_cache_limit：能够缓存的最大结果。如果查询结果大于这个值，不会缓存。如果预先知道会有这种情况，最好查询语句里直接指定SQL_NO_CACHE。

