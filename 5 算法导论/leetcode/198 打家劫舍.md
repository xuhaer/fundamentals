你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例：
    [2, 7, 3] 输出: 7
    [2, 7, 3, 9, 1] 输出: 16

打家劫舍这一类问题分别在No198，No213和No337，本题是这一类问题最简单的一种状态，第一直觉就应该是动态规划，如官方题解，设f(x)为打劫前x家房子所能得到的最大的资金，很容易想到动态规划的边界条件，即：
f(1)=nums[1]
f(2)=max(nums[1],nums[2])

然后是最关键的动态转移方程，如果要打劫第n家，就必然不能打劫第n-1家，所以打劫第n家得到的钱一共是第n家的钱加上前n-2家获得的最多的钱，即：f(n-2)+nums(n)，如果不打劫第n家，获得的最大收益就是f(n-1)，两者我们要去较大的那个，所以动态转移方程是：
f(n)=max(nums[n]+f(n-2),f(n-1))


再看第213题，打家劫舍II，本质上还是这个动态转移方程，只不过把房子首尾相连，如果打劫了第一家就不能打劫最后一家，那么我们还是可以按照这题的方法，先假设第一家一定去打劫，最后一家一定不打劫（f(1)=f(2)=nums(1)，只计算到第n-1位），然后假设第一家一定不打劫，而最后一家一定要去打劫（f(1)=0 , f(2)=nums(2)，计算到最后），取两者中的最大值就行了。


**着重考虑一下第三种情况：** 第337题打家劫舍III又做了一点变化，把社区规划成了树形(二叉树)，如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

要获取当前节点最优解的，就要先获取左右子树的最优解情况。在二叉树中，先左右子树，再自身节点的，就是后序遍历了，也可以认为是深度优先遍历。

获取到左右子树解之后，怎么处理当前节点的最优解呢？分为两种情况：

1.选择当前节点，那么只能获取不选中左右孩子的解，即
chooseVal = node.val + noChoose(node.left) + noChoose(node.right)

2.不选择当前节点，左右孩子并不是简单的取选中解。此时左右孩子的选择没有了任何限制（因为父节点不选了），所以，当前节点不选的最优解为=左孩子选或不选的较大值+右子树选或不选的较大值。这个才是不选当前节点的最优解，即
noChooseVal = max(choose(node.left),noChose(node.left)) + max(choose(node.right),noChoose(node.right))

这样，当前节点的两种情况也得到了，然后只要继续返回给上一层，重复最优解的获取即可。

最终回到root节点时，取两种最优结果的较大值，就可以得到全局的最优解。以上思想，亦是动态规划拆解子问题的思想。
```python
# 伪代码如下:
# 选中根节点的情况，左右孩子是不选的
# 下面的 0代表选择当前节点的最大情况，1代表不选当前节点的最大情况
choose = node.val + leftRes[1] + rightRes[1]
# 不选根节点的情况，左右孩子任意节点可选，所以要取左右孩子选或不选两者情况的较大值累加
# 即左子树的最优解+右子树的最优解
noChoose = max(leftRes[0], leftRes[1]) + max(rightRes[0], rightRes[1])

return max(choose, noChoose)
```
