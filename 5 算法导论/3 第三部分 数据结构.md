# 第三部分 数据结构
集合作为计算机科学的基础，就如同他们在数学中所起的作用。不同的是，数学中的集合是不变的，而由算法操作的集合确实动态的。下面的几章将介绍在计算机上表示和操作有限动态集合的一些基本技术。

第10~14章描述能够用于实现动态集合的几种数据结构，本书后面将是同其中多种构造解决各种不同问题的有效算法。

第10章给出一些简单数据结构的使用基础，如栈、列队、链表和有根树。
第11章介绍散列表，最坏情况下，散列表完成一次search 操作需要 O(n)时间，但散列表上操作的期望时间为O(1)。
第12章介绍二叉搜索树，它支持常见的所有的动态集合操作。最坏情况下，在有 n 个元素的一棵树上，一次操作需要 O(n)时间；然而在随机构建的一棵二叉搜索树上，其一次操作的期望时间为 O(lgn)。
第13章介绍红黑树，这是二叉搜索树的一个变种。与普通的二叉搜索树不同，红黑树保证了较好的性能：最坏情况下各种操作只需要 O(lgn)时间，一棵红黑树是一种平衡搜索树，第5部分的第18章将涉及另一种平衡搜索树，称为 B 树。
第14章给出如何将红黑树进行扩张，使其支持一些基本操作以外的操作。


## 第10章 基本数据结构

### 栈和列队
栈和列队都是动态集合，且在其上进行 delete 操作所移除的元素是预先设定的。在`栈(stack)`中，被删除的是最近插入的元素：栈实现的是一种`后进后出(last-in,first-out,LIFO)`策略。相应地，在`列队(queue)`中，被删去的总是在集合中存在时间最长的那个元素：队列实现的是一种`先进先出(first-in, first-out,FIFO)`策略。

### 链表
`链表(linked list)`是一种这样的数据结构，其中各对象按线性顺序排列。数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。
链表可以有多种形式，它可以是单链接的或者是双链接的，可以是已排序的或者未排序的，可以是循环的或非循环的。在本节余下的部分中，所处理的链表都是未排序的且是双链接的。

### 二叉树
`二叉树(Binary tree)`是每个节点最多只有两个分支的树结构。通常分支被称作“左子树(左孩子)”或“右子树(右孩子)”。
二叉树的表示方法可以推广到每个结点的孩子数至多为常数 k 的任意类型的数：只需要将 left 和 right 属性用 child1, child2 ... childk代替，当孩子的节点数无限时，该方法就失效了。此外，即是将 k 限制在一个大的常数以内，若多数结点只有少量孩子时，也会浪费大量储存空间。
所幸的是，有一个巧妙的方法可以用来表示孩子数任意的树(当然，树的表示方法很多)。该方法的优势在于，对于任意 n 个结点的有根树，只需要O(n)的存储空间: `左孩子右兄弟表示法(left-child, right-sibling representation)`。其每个节点都包含了一个父节点指针 p，且 T.root 指向树 T 的根节点，然而每个结点中不是包含指向2个孩子的指针：

<img src='./figure/left_child_right_sibling.png'  width='600' />


## 第11章 散列表

`散列表(Hash table，也叫哈希表)`，是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。
这个映射函数称做散列函数，存放记录的数组称做散列表。

